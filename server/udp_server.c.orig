/*
 *****************************************************************************
 *
 * File:    udp_server.c
 *
 * Purpose: Collect SPA packets via a UDP server.
 *
 *  Fwknop is developed primarily by the people listed in the file 'AUTHORS'.
 *  Copyright (C) 2009-2014 fwknop developers and contributors. For a full
 *  list of contributors, see the file 'CREDITS'.
 *
 *  License (GNU General Public License):
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 *  USA
 *
 *****************************************************************************
*/
#include "fwknopd_common.h"
#include "incoming_spa.h"
#include "log_msg.h"
#include "fw_util.h"
#include "utils.h"
#include <errno.h>

#if HAVE_SYS_SOCKET_H
  #include <sys/socket.h>
#endif
#if HAVE_ARPA_INET_H
  #include <arpa/inet.h>
#endif
#if HAVE_NETDB
  #include <netdb.h>
#endif

#include <fcntl.h>
#include <sys/select.h>

int
run_udp_server(fko_srv_options_t *opts)
{
    int                 is_err, pkt_len, sock_fd = 0;
    char msg[5000];
    struct sockaddr_in  saddr, caddr;
    char                sipbuf[MAX_IPV4_STR_LEN] = {0};

    unsigned short      port;
    socklen_t len;

    port = strtol_wrapper(opts->config[CONF_UDPSERV_PORT],
            1, MAX_PORT, NO_EXIT_UPON_ERR, &is_err);
    if(is_err != FKO_SUCCESS)
    {
        log_msg(LOG_ERR, "[*] Invalid max UDPSERV_PORT value.");
        return -1;
    }
    log_msg(LOG_INFO, "Kicking off UDP server to listen on port %i.", port);

    /* Now, let's make a UDP server
    */
    sock_fd = socket(AF_INET,SOCK_DGRAM,0);

    bzero(&saddr,sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr=htonl(INADDR_ANY);
    saddr.sin_port=htons(port);
    bind(sock_fd,(struct sockaddr *)&saddr,sizeof(saddr));

    while(1)
    {
        len = sizeof(caddr);
        pkt_len = recvfrom(sock_fd,msg,5000,0,(struct sockaddr *)&caddr,&len);
        //sendto(sock_fd,msg,pkt_len,0,(struct sockaddr *)&caddr,sizeof(caddr));
        printf("-------------------------------------------------------\n");
        msg[pkt_len] = 0;
        printf("Received %d bytes:\n", pkt_len);
        printf("%s",msg);
        printf("\n-------------------------------------------------------\n");

        memset(sipbuf, 0x0, MAX_IPV4_STR_LEN);
        inet_ntop(AF_INET, &(caddr.sin_addr.s_addr), sipbuf, MAX_IPV4_STR_LEN);
        log_msg(LOG_INFO, "udp_server: Got UDP datagram from %s.", sipbuf);

        /* Copy the packet for SPA processing
        */
        strlcpy((char *)opts->spa_pkt.packet_data, msg, pkt_len+1);
        opts->spa_pkt.packet_data_len = pkt_len;
        opts->spa_pkt.packet_proto    = IPPROTO_UDP;
        opts->spa_pkt.packet_src_ip   = caddr.sin_addr.s_addr;
        opts->spa_pkt.packet_dst_ip   = saddr.sin_addr.s_addr;
        opts->spa_pkt.packet_src_port = ntohs(caddr.sin_port);
        opts->spa_pkt.packet_dst_port = ntohs(saddr.sin_port);

        incoming_spa(opts);

        /* Check for any expired firewall rules and deal with them.
        */
        if(!opts->test)
            check_firewall_rules(opts);
    }

    return 1;
}

/***EOF***/
